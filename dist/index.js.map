{"version":3,"file":"index.js","mappings":";AAAA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack/runtime/compat",".././lib/main.js"],"sourcesContent":["\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cleanup = cleanup;\nconst core = __importStar(require(\"@actions/core\"));\nconst fs = __importStar(require(\"fs\"));\nconst androidpublisher_1 = require(\"@googleapis/androidpublisher\");\nlet serviceAccountFile = './serviceAccountJson.json';\nlet isServiceAccountJsonRaw = false;\nfunction run() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Code initially taken from https://github.com/boswelja/promote-play-beta-action\n            const packageName = core.getInput('package-name', { required: true });\n            const rawServiceAccountJson = core.getInput('service-account-json-raw');\n            const serviceAccountJsonFile = core.getInput('service-account-json-file');\n            isServiceAccountJsonRaw = !!rawServiceAccountJson;\n            // Validate that at least one credential method is provided\n            if (!rawServiceAccountJson && !serviceAccountJsonFile) {\n                throw new Error('Either service-account-json-raw or service-account-json-file must be provided');\n            }\n            // If both are provided, prefer the file method\n            if (rawServiceAccountJson && serviceAccountJsonFile) {\n                core.warning('Both service-account-json-raw and service-account-json-file are provided. Using service-account-json-file.');\n            }\n            const inAppUpdatePriority = parseInt(core.getInput('inapp-update-priority'));\n            const userFraction = parseFloat(core.getInput('user-fraction'));\n            const fromTrack = core.getInput('from-track');\n            const toTrack = core.getInput('to-track');\n            // Handle credentials based on which method is provided\n            if (serviceAccountJsonFile) {\n                // Use the file provided by google-github-actions/auth\n                core.debug(`Using service account JSON from file: ${serviceAccountJsonFile}`);\n                serviceAccountFile = serviceAccountJsonFile;\n            }\n            else {\n                // Write the raw JSON to a file\n                core.debug('Writing service account JSON to file, setting env variable so auth can find it');\n                yield fs.promises.writeFile(serviceAccountFile, rawServiceAccountJson, {\n                    encoding: 'utf8'\n                });\n                serviceAccountFile = yield fs.promises.realpath(serviceAccountFile);\n            }\n            core.exportVariable('GOOGLE_APPLICATION_CREDENTIALS', serviceAccountFile);\n            core.debug('Authenticating: creating auth client');\n            const authClient = new androidpublisher_1.auth.GoogleAuth({\n                scopes: ['https://www.googleapis.com/auth/androidpublisher']\n            });\n            const publisher = (0, androidpublisher_1.androidpublisher)('v3');\n            core.info('Creating a new app edit');\n            const appEdit = yield publisher.edits.insert({\n                packageName,\n                auth: authClient\n            });\n            const appEditId = appEdit.data.id;\n            if (!appEditId) {\n                throw new Error(`appEditId is not defined. Data: ${appEdit.data}`);\n            }\n            core.info(`Getting current ${fromTrack} info`);\n            const sourceTrack = yield publisher.edits.tracks.get({\n                auth: authClient,\n                packageName,\n                editId: appEditId,\n                track: fromTrack\n            });\n            core.debug(`Mapping ${fromTrack} releases to target releases`);\n            core.debug(`Applying new fraction ${userFraction}, new priority ${inAppUpdatePriority}`);\n            const sourceReleases = sourceTrack.data.releases;\n            if (!sourceReleases) {\n                throw new Error(`sourceReleases is not defined. Data: ${sourceTrack.data}`);\n            }\n            const toTrackReleases = sourceReleases.map(release => {\n                release.inAppUpdatePriority = inAppUpdatePriority;\n                if (userFraction === 1.0) {\n                    // Assume this release is completed, and fully roll it out\n                    release.status = 'completed';\n                }\n                else {\n                    // See https://developers.google.com/android-publisher/api-ref/rest/v3/edits.tracks#status\n                    // The API requires us to explicitly set this for some reason\n                    // Otherwise, you get an error: `Error: Release status must be specified.`\n                    release.userFraction = userFraction;\n                    release.status = 'inProgress';\n                }\n                return release;\n            });\n            core.info(`Switching ${fromTrack} release to ${toTrack}`);\n            yield publisher.edits.tracks.update({\n                auth: authClient,\n                editId: appEditId,\n                track: toTrack,\n                packageName,\n                requestBody: {\n                    track: toTrack,\n                    releases: toTrackReleases\n                }\n            });\n            core.info('Committing changes');\n            const commitResult = yield publisher.edits.commit({\n                auth: authClient,\n                editId: appEditId,\n                packageName\n            });\n            // Check commit was successful\n            if (!commitResult.data.id) {\n                throw new Error(`Error ${commitResult.status}: ${commitResult.statusText}`);\n            }\n            core.info(`Successfully promoted release to ${toTrack}`);\n        }\n        catch (error) {\n            if (error instanceof Error)\n                core.setFailed(error.message);\n        }\n    });\n}\nfunction cleanup() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Only delete the file if we created it (not if it was provided)\n        if (isServiceAccountJsonRaw) {\n            try {\n                yield fs.promises.unlink(serviceAccountFile);\n            }\n            catch (error) {\n                core.warning(`Failed to delete temporary service account file: ${error}`);\n            }\n        }\n    });\n}\nrun();\n"],"names":[],"sourceRoot":""}